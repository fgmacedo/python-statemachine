# StateMachine 2.3.0

*Not released yet*

## What's new in 2.3.0

In this release, we conducted a significant update focusing on adding asynchronous support, and enhancing overall functionality. In fact, the approach we took was to go all the way down changing the internals of the library to be fully async, keeping only the current external API as a thin sync wrapper.

Here are the major changes and new features:

### Asynchronous Support

This release introduces native coroutine support using asyncio, enabling seamless integration with asynchronous code.

Now you can send and await for events, and also write async {ref}`Actions`, {ref}`Conditions` and {ref}`Validators`.


```{seealso}
See {ref}`sphx_glr_auto_examples_air_conditioner_machine.py` for an example of
async code mixed with a state machine.
```


```py
>>> from statemachine.utils import run_async_from_sync
>>> from statemachine import StateMachine, State

>>> class AsyncStateMachine(StateMachine):
...     initial = State('Initial', initial=True)
...     final = State('Final')
...
...     advance = initial.to(final)

>>> async def run_sm():
...     sm = AsyncStateMachine()
...     await sm.advance()
...     print(sm.current_state)

>>> run_async_from_sync(run_sm())
Final

```

### Manual Initial State Activation for Async Code

Users must now manually activate the initial state when working with asynchronous state machines. This change ensures proper state initialization and execution flow.

```py
>>> async def initialize_sm():
...     sm = AsyncStateMachine()
...     await sm.activate_initial_state()
...     return sm

>>> sm = run_async_from_sync(initialize_sm())
>>> print(sm.current_state)
Initial

```
